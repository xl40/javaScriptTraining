<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        
    </style>
</head>
<body>
    
</body>
<script>
    // 内置的工厂模式就是构造自定义函数

    function Fn(m){
        // 属性的加工，放在构造函数内
        this.msg = m;
    }
    // 方法的加工，放在构造函数的prototype身上
    Fn.prototype.show = function(){
        console.log(this.msg);
    }
    // 因为最终执行方式的原因，导致构造函数的prototype身上的方法中的this和构造函数内的this都是将来new出来的对象
    // const f1 = new Fn("hello");
    // f1.show();
    // const f2 = new Fn("hi");
    // f2.show();
    // console.log(f1 === f2);
    // console.log(f1.show === f2.show);

    // 直接执行会导致构造函数内所有给this加工的属性，都变成全局变量
    // const f = Fn("hahahha");
    // console.log(f);

    // 所以，为了区分构造函数函数的执行和非构造函数的执行，行业内统一规定，构造函数的命名采取大驼峰式（也是一种建议）


</script>
</html>