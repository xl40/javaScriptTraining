# 一、复习
1. 作用域
    - 数据生效的区域
    - 全局：不属于任何函数，全局变量，一直存在，栈内存
    - 局部：属于某个函数，局部变量，朝生暮死，节省内存，但是操作麻烦
    - 规则：
        - 父作用域不能使用子作用域内的数据，子作用域可以使用父作用域内的数据。兄弟作用域不能互相使用数据
        - 嵌套时，多层作用域都有相同数据：逐层向上，就近原则
    - 先在代码控件中开启匿名函数，然后在匿名函数中完成所有功能
        - 并不是真正的全局，但有全局的优势（方便）
        - 匿名函数：(function(){})()
            - 自动执行
2. 声明提升
    - 提升：提升到当前作用域最开始的位置
    - 声明变量：提前声明，原位赋值
    - 声明函数：整体提升
    - 变量遇到函数：
        - 重名：不允许，var的声明提升，function的声明鸠占鹊巢，所以function生效
            - `var a = "hello"; function a(){}`
        - 赋值式创建函数：提升的是var，function并没有声明某个变量
            - `var a = function(){}`
3. 递归
    - 函数的执行方式，在函数内部执行自身，会消耗大量内存，并不推荐大量使用，但是递归是一种很好的编程思想
    - 递：不断向内执行自身
    - 归：不断向外返回结果
    - 重要：递的终点，归的起点：递归的终止条件
4. 函数的分类
    - 有名：正常
    - 无名：非正常，作为值使用
        - 1. 2. 3. 4. 5. 
    - 匿名：自动执行，用来生成作用域

# 二、作业
1. 利用递归求两个数字最大公约数（看图写代码）
2. 编写一个函数，输入n为偶数时，调用函数求1/2+1/4+...+1/n,当输入n为奇数时，调用函数求1+1/3+...+1/n    循环和递归
3. 尝试：利用递归求两个数字最小公倍数

# 三、数组
1. 数组的概念：数组，数据的组合，一组数据，数据的一种打包形式，将多个数据打包成一个数据，打包之后的数据在数组内顺序排列。所以数组也是数据的有序集合。
2. 数组的意义：当需要操作多个数据，但只能操作一个数据时。
    - 如：函数的返回值，只能返回一个
    - 提醒：要想使用数组内的数据，必须先解析数组，才能拿到内部的数据
3. 创建数组：[]
    - 字面量创建：`var arr1 = [];`
        - 字面量创建，就是通过数据的标志创建，字面意思的量
    - 构造函数创建：`var arr2 = new Array();`
        - 构造函数创建，其实是利用了js万物皆对象的特点，通过对象创建
    - 区别：当有且只有一个数值型数据时，字面量就是作为一个数据，构造函数会将这个数据作为长度存在，每个位置暂时为undefined
4. 对象的特点（补充，提前了解，后期会深入）
    - js中万物皆对象（构造函数方式创建数据）
    - 任何两个对象都不相等，如果相等了，意味着他们是同一个对象
5. 数组的操作 - 根据操作方式划分
    - 直接操作：- 理解
        - 数组内的数据，是按照索引从0开始排列，数组中共有length个数据，所以数组最后一个数据的索引为自身的length-1
        - 语法：
            - 数组[索引]
            - 数组.length
        - 操作：
            - 查：
                - 根据索引查具体的某个数据：数组[索引]
                - 查所有：利用循环，计算索引，依次查询
            - 改：
                - 针对数组中的某个位置，重新赋值，就是修改
            - 增：见代码
            - 删：见代码
    - 利用官方提供的工具操作：- 背
        - 数组的方法，就是函数，只不过是属于数组的函数，只能通过数组使用，不能直接使用
            - 语法：数组.方法名()
        - 分类
            - 末尾插入：arr.push(要插入的数据)
            - 开头插入：arr.unshift(要插入的数据)
            - 末尾删除：arr.pop()
            - 开头删除：arr.shift()
            - 删除中间并替换：arr.splice(从哪开始删, 删除几个, 要替换的新数据)
            - 合并：arr.concat(新数据)
            - 截取：arr.slice(从哪开始截, 截到哪)
            - 转字符：arr.join(连接符)
            - 排序：arr.sort(回调函数)
    
6. 数组打包建议和分类
    - 什么样的数据适合打包成数组？
        - 同类数据适合打包成数组
        - 如：全是姓名，全是手机号，全是爱好，...
    - 分类
        - 全是字符的数组，叫字符数组
        - 全是数值的数组，叫数值数组
        - 全是函数的数组，叫函数数组
        - 全是对象的数组，叫对象数组，也叫json数组
            - [{},{},{},{},{}]
        - 全是数组的数组，叫数组数组，也叫二维数组，或多维数组
            - [[], [], [], [],[]]
    - 复杂数组（json数组和多维数组）的解析方式
        - 从外层向内层，逐层解析

# 四、计算机的内存存储机制
1. 计算机：电脑，可以执行一些程序，可以存储数据
2. 硬盘：是容量比较大的那个，如：500G，800G，1T
    - 永久存储数据
3. 内存：是容量比较小的那个，如：4G，8G，16G，32G
    - 临时存储数据
4. 内存的存储机制（程序执行过程中数据的存储）
    - 栈：空间比较小，稳定，不可修改，一般用来存储变量名
    - 堆：空间较大，灵活，可被修改，一般用来存储具体的数据
    - 关系：
        - 栈和堆一一对应，可以多对一，不能一对多
        - 在栈中，除了变量名之外，还会存储堆的地址

# 五、根据内存存储方式的数据分类
1. 基本数据（值传递）
    - 不仅变量名存在栈中，数据也存在栈中。不占堆。
    - string，number，boolean，undefined，null
2. 复杂数据（引用传递）
    - 变量名存储在栈中，数据存储在堆中，栈中在保存堆的地址
    - object，array，function

# 六、复杂数据的深浅拷贝
1. 浅拷贝：拷贝数据时，只要拷贝地址。修改了新值，会影响老值
    ```js
    var arr1 = [4,5,6,7];
    var arr2 = arr1;        // 此处正在拷贝
    // 修改可拷贝之后的数据
    arr2[2] = "啊";
    console.log(arr1);      // [4, 5, '啊', 7]
    console.log(arr2);      // [4, 5, '啊', 7]
    ```
2. 深拷贝：拷贝数据时，不拷贝地址，只拷贝值。修改新值，不会影响老值
    ```js
    var arr1 = [4,5,6,7];
    var arr2 = [];          // 创建一个新堆地址
    // 将老堆地址内的数据，拷贝到新堆地址中
    for(var i=0;i<arr1.length;i++){
        arr2[i] = arr1[i];
    }
    // 修改可拷贝之后的数据
    arr2[2] = "啊";
    console.log(arr1);      // [4, 5, 6, 7]
    console.log(arr2);      // [4, 5, '啊', 7]
    ```


# 作业 - 思考
1. 测试：每个数组方法的返回值
    - console.log(数组.push())
    - 数组.shift()
    - 数组.pop()
    - 数组.unshift()
    - ...
2. 编写函数 map(arr)，把数组中的每一位数字都增加30%
3. 编写函数 has(arr, 60)，判断数组中是否存在60这个数据，返回布尔值
4. 编写函数 norepeat(arr)，将数组的重复数据去掉，并返回新的数组
5. 编写函数 insert(arr, 4)，arr是一个从小到大排好序的数组。现输入一个数，要求按原来的规律将它插入数组中
